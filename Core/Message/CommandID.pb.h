// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: CommandID.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_CommandID_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_CommandID_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_CommandID_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_CommandID_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[1]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
void AddDescriptors_CommandID_2eproto();
PROTOBUF_NAMESPACE_OPEN
PROTOBUF_NAMESPACE_CLOSE
namespace message {

enum CL_CommandID {
  CL_COMMAND_NONE = 0,
  CL_COMMAND_VERSION_REQUEST = 1001,
  CL_COMMAND_LOGIN_REQUEST = 1002,
  CL_CommandID_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  CL_CommandID_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool CL_CommandID_IsValid(int value);
constexpr CL_CommandID CL_CommandID_MIN = CL_COMMAND_NONE;
constexpr CL_CommandID CL_CommandID_MAX = CL_COMMAND_LOGIN_REQUEST;
constexpr int CL_CommandID_ARRAYSIZE = CL_CommandID_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CL_CommandID_descriptor();
inline const std::string& CL_CommandID_Name(CL_CommandID value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CL_CommandID_descriptor(), value);
}
inline bool CL_CommandID_Parse(
    const std::string& name, CL_CommandID* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CL_CommandID>(
    CL_CommandID_descriptor(), name, value);
}
enum LC_CommandID {
  LC_COMMAND_NONE = 0,
  LC_COMMAND_VERSION_RESPONSE = 5001,
  LC_COMMAND_LOGIN_RESPONSE = 5002,
  LC_CommandID_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  LC_CommandID_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool LC_CommandID_IsValid(int value);
constexpr LC_CommandID LC_CommandID_MIN = LC_COMMAND_NONE;
constexpr LC_CommandID LC_CommandID_MAX = LC_COMMAND_LOGIN_RESPONSE;
constexpr int LC_CommandID_ARRAYSIZE = LC_CommandID_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LC_CommandID_descriptor();
inline const std::string& LC_CommandID_Name(LC_CommandID value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LC_CommandID_descriptor(), value);
}
inline bool LC_CommandID_Parse(
    const std::string& name, LC_CommandID* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LC_CommandID>(
    LC_CommandID_descriptor(), name, value);
}
enum CA_CommandID_Assist {
  CA_COMMAND_DIAGNOSIS_NONE = 0,
  CA_COMMAND_DIAGNOSIS_BASE_LIST_REQUEST = 3001,
  CA_COMMAND_DIAGNOSIS_HEARTBEAT_REQUEST = 3002,
  CA_COMMAND_DIAGNOSIS_BEGIN_REQUEST = 3003,
  CA_COMMAND_DIAGNOSIS_PASSWORD_MODIFY_REQUEST = 3004,
  CA_COMMAND_DIAGNOSIS_AVATAR_MODIFY_REQUEST = 3005,
  CA_COMMAND_DIAGNOSIS_CALL_RESPONSE_REQUEST = 3006,
  CA_COMMAND_DIAGNOSIS_PAUSE_RECOVER_REQUEST = 3007,
  CA_COMMAND_DIAGNOSIS_PASS_RECOVER_REQUEST = 3008,
  CA_COMMAND_DIAGNOSIS_LEAVE_REQUEST = 3009,
  CA_COMMAND_DIAGNOSIS_LEAVE_RECOVER_REQUEST = 3010,
  CA_COMMAND_DIAGNOSIS_COMPLETE_REQUEST = 3011,
  CA_COMMAND_DIAGNOSIS_SPARE_REQUEST = 3012,
  CA_COMMAND_DIAGNOSIS_HISTORY_REQUEST = 3013,
  CA_CommandID_Assist_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  CA_CommandID_Assist_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool CA_CommandID_Assist_IsValid(int value);
constexpr CA_CommandID_Assist CA_CommandID_Assist_MIN = CA_COMMAND_DIAGNOSIS_NONE;
constexpr CA_CommandID_Assist CA_CommandID_Assist_MAX = CA_COMMAND_DIAGNOSIS_HISTORY_REQUEST;
constexpr int CA_CommandID_Assist_ARRAYSIZE = CA_CommandID_Assist_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CA_CommandID_Assist_descriptor();
inline const std::string& CA_CommandID_Assist_Name(CA_CommandID_Assist value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CA_CommandID_Assist_descriptor(), value);
}
inline bool CA_CommandID_Assist_Parse(
    const std::string& name, CA_CommandID_Assist* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CA_CommandID_Assist>(
    CA_CommandID_Assist_descriptor(), name, value);
}
enum CA_CommandID_Experts {
  CA_COMMAND_DOCTOR_NONE = 0,
  CA_COMMAND_DOCTOR_BASE_LIST_REQUEST = 4001,
  CA_COMMAND_DOCTOR_HEARTBEAT_REQUEST = 4002,
  CA_COMMAND_DOCTOR_BEGIN_REQUEST = 4003,
  CA_COMMAND_DOCTOR_PASSWORD_MODIFY_REQUEST = 4004,
  CA_COMMAND_DOCTOR_AVATAR_MODIFY_REQUEST = 4005,
  CA_COMMAND_DOCTOR_CALL_REQUEST = 4006,
  CA_COMMAND_DOCTOR_SURE_PASS_REQUEST = 4007,
  CA_COMMAND_DOCTOR_STOP_REQUEST = 4008,
  CA_COMMAND_DOCTOR_PAUSE_REQUEST = 4009,
  CA_COMMAND_DOCTOR_LEAVE_REQUEST = 4010,
  CA_COMMAND_DOCTOR_LEAVE_RECOVER_REQUEST = 4011,
  CA_COMMAND_DOCTOR_COMPLETE_REQUEST = 4012,
  CA_COMMAND_DOCTOR_HISTORY_REQUEST = 4013,
  CA_COMMAND_DOCTOR_HISTORY_ADD_REQUEST = 4014,
  CA_CommandID_Experts_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  CA_CommandID_Experts_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool CA_CommandID_Experts_IsValid(int value);
constexpr CA_CommandID_Experts CA_CommandID_Experts_MIN = CA_COMMAND_DOCTOR_NONE;
constexpr CA_CommandID_Experts CA_CommandID_Experts_MAX = CA_COMMAND_DOCTOR_HISTORY_ADD_REQUEST;
constexpr int CA_CommandID_Experts_ARRAYSIZE = CA_CommandID_Experts_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CA_CommandID_Experts_descriptor();
inline const std::string& CA_CommandID_Experts_Name(CA_CommandID_Experts value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CA_CommandID_Experts_descriptor(), value);
}
inline bool CA_CommandID_Experts_Parse(
    const std::string& name, CA_CommandID_Experts* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CA_CommandID_Experts>(
    CA_CommandID_Experts_descriptor(), name, value);
}
enum AC_CommandID_Assist {
  AC_COMMAND_NONE_DIAGNOSIS = 0,
  AC_COMMAND_DIAGNOSIS_BASE_RESPONSE = 7001,
  AC_COMMAND_DIAGNOSIS_HEARTBEAT_RESPONSE = 7002,
  AC_COMMAND_DIAGNOSIS_BEGIN_RESPONSE = 7003,
  AC_COMMAND_DIAGNOSIS_PASSWORD_MODIFY_RESPONSE = 7004,
  AC_COMMAND_DIAGNOSIS_AVATAR_MODIFY_RESPONSE = 7005,
  AC_COMMAND_DIAGNOSIS_ACCEPT_CALL_PUSH = 7006,
  AC_COMMAND_DIAGNOSIS_RESPONSE_CALL_RESPONSE = 7007,
  AC_COMMAND_DIAGNOSIS_PAUSE_PUSH = 7008,
  AC_COMMAND_DIAGNOSIS_PAUSE_RECOVER_RESPONSE = 7009,
  AC_COMMAND_DIAGNOSIS_PASS_RECOVER_RESPONSE = 7010,
  AC_COMMAND_DIAGNOSIS_LIST_PUSH = 7011,
  AC_COMMAND_DOCTOR_SURE_PASS_PUSH = 7012,
  AC_COMMAND_DIAGNOSIS_LEAVE_RESPONSE = 7013,
  AC_COMMAND_DIAGNOSIS_LEAVE_RECOVER_RESPONSE = 7014,
  AC_COMMAND_DIAGNOSIS_COMPLETE_RESPONSE = 7015,
  AC_COMMAND_DIAGNOSIS_SPARE_RESPONSE = 7016,
  AC_COMMAND_DIAGNOSIS_COMPLETE_PUSH = 7017,
  AC_COMMAND_DIAGNOSIS_HISTORY_RESPONSE = 7018,
  AC_CommandID_Assist_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  AC_CommandID_Assist_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool AC_CommandID_Assist_IsValid(int value);
constexpr AC_CommandID_Assist AC_CommandID_Assist_MIN = AC_COMMAND_NONE_DIAGNOSIS;
constexpr AC_CommandID_Assist AC_CommandID_Assist_MAX = AC_COMMAND_DIAGNOSIS_HISTORY_RESPONSE;
constexpr int AC_CommandID_Assist_ARRAYSIZE = AC_CommandID_Assist_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AC_CommandID_Assist_descriptor();
inline const std::string& AC_CommandID_Assist_Name(AC_CommandID_Assist value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AC_CommandID_Assist_descriptor(), value);
}
inline bool AC_CommandID_Assist_Parse(
    const std::string& name, AC_CommandID_Assist* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AC_CommandID_Assist>(
    AC_CommandID_Assist_descriptor(), name, value);
}
enum AC_CommandID_Experts {
  AC_COMMAND_DOCTOR_NONE = 0,
  AC_COMMAND_DOCTOR_BASE_RESPONSE = 8001,
  AC_COMMAND_DOCTOR_HEARTBEAT_RESPONSE = 8002,
  AC_COMMAND_DOCTOR_BEGIN_RESPONSE = 8003,
  AC_COMMAND_DOCTOR_CALL_RESPONSE = 8004,
  AC_COMMAND_DOCTOR_ACCEPT_CALL_RESULT_PUSH = 8005,
  AC_COMMAND_DOCTOR_SURE_PASS_RESPONSE = 8006,
  AC_COMMAND_DOCTOR_STOP_RESPONSE = 8007,
  AC_COMMAND_DOCTOR_PAUSE_RESPONSE = 8008,
  AC_COMMAND_DOCTOR_PASSWORD_MODIFY_RESPONSE = 8009,
  AC_COMMAND_DOCTOR_AVATAR_MODIFY_RESPONSE = 8010,
  AC_COMMAND_DOCTOR_LIST_PUSH = 8011,
  AC_COMMAND_DOCTOR_ROOM_ID_PUSH = 8012,
  AC_COMMAND_DOCTOR_LEAVE_RESPONSE = 8013,
  AC_COMMAND_DOCTOR_LEAVE_RECOVER_RESPONSE = 8014,
  AC_COMMAND_DOCTOR_COMPLETE_RESPONSE = 8015,
  AC_COMMAND_DOCTOR_HISTORY_RESPONSE = 8016,
  AC_COMMAND_DOCTOR_HISTORY_ADD_RESPONSE = 8017,
  AC_CommandID_Experts_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  AC_CommandID_Experts_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool AC_CommandID_Experts_IsValid(int value);
constexpr AC_CommandID_Experts AC_CommandID_Experts_MIN = AC_COMMAND_DOCTOR_NONE;
constexpr AC_CommandID_Experts AC_CommandID_Experts_MAX = AC_COMMAND_DOCTOR_HISTORY_ADD_RESPONSE;
constexpr int AC_CommandID_Experts_ARRAYSIZE = AC_CommandID_Experts_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AC_CommandID_Experts_descriptor();
inline const std::string& AC_CommandID_Experts_Name(AC_CommandID_Experts value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AC_CommandID_Experts_descriptor(), value);
}
inline bool AC_CommandID_Experts_Parse(
    const std::string& name, AC_CommandID_Experts* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AC_CommandID_Experts>(
    AC_CommandID_Experts_descriptor(), name, value);
}
// ===================================================================


// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)

}  // namespace message

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::message::CL_CommandID> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::message::CL_CommandID>() {
  return ::message::CL_CommandID_descriptor();
}
template <> struct is_proto_enum< ::message::LC_CommandID> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::message::LC_CommandID>() {
  return ::message::LC_CommandID_descriptor();
}
template <> struct is_proto_enum< ::message::CA_CommandID_Assist> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::message::CA_CommandID_Assist>() {
  return ::message::CA_CommandID_Assist_descriptor();
}
template <> struct is_proto_enum< ::message::CA_CommandID_Experts> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::message::CA_CommandID_Experts>() {
  return ::message::CA_CommandID_Experts_descriptor();
}
template <> struct is_proto_enum< ::message::AC_CommandID_Assist> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::message::AC_CommandID_Assist>() {
  return ::message::AC_CommandID_Assist_descriptor();
}
template <> struct is_proto_enum< ::message::AC_CommandID_Experts> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::message::AC_CommandID_Experts>() {
  return ::message::AC_CommandID_Experts_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_CommandID_2eproto
