// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: IMessage.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_IMessage_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_IMessage_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_IMessage_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_IMessage_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[3]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
void AddDescriptors_IMessage_2eproto();
namespace message {
class HeadClient;
class HeadClientDefaultTypeInternal;
extern HeadClientDefaultTypeInternal _HeadClient_default_instance_;
class HeadServer;
class HeadServerDefaultTypeInternal;
extern HeadServerDefaultTypeInternal _HeadServer_default_instance_;
class PNPCMessage;
class PNPCMessageDefaultTypeInternal;
extern PNPCMessageDefaultTypeInternal _PNPCMessage_default_instance_;
}  // namespace message
PROTOBUF_NAMESPACE_OPEN
template<> ::message::HeadClient* Arena::CreateMaybeMessage<::message::HeadClient>(Arena*);
template<> ::message::HeadServer* Arena::CreateMaybeMessage<::message::HeadServer>(Arena*);
template<> ::message::PNPCMessage* Arena::CreateMaybeMessage<::message::PNPCMessage>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace message {

// ===================================================================

class PNPCMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:message.PNPCMessage) */ {
 public:
  PNPCMessage();
  virtual ~PNPCMessage();

  PNPCMessage(const PNPCMessage& from);
  PNPCMessage(PNPCMessage&& from) noexcept
    : PNPCMessage() {
    *this = ::std::move(from);
  }

  inline PNPCMessage& operator=(const PNPCMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline PNPCMessage& operator=(PNPCMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const PNPCMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PNPCMessage* internal_default_instance() {
    return reinterpret_cast<const PNPCMessage*>(
               &_PNPCMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(PNPCMessage* other);
  friend void swap(PNPCMessage& a, PNPCMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PNPCMessage* New() const final {
    return CreateMaybeMessage<PNPCMessage>(nullptr);
  }

  PNPCMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PNPCMessage>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PNPCMessage& from);
  void MergeFrom(const PNPCMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PNPCMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "message.PNPCMessage";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes msgHead = 1;
  void clear_msghead();
  static const int kMsgHeadFieldNumber = 1;
  const std::string& msghead() const;
  void set_msghead(const std::string& value);
  void set_msghead(std::string&& value);
  void set_msghead(const char* value);
  void set_msghead(const void* value, size_t size);
  std::string* mutable_msghead();
  std::string* release_msghead();
  void set_allocated_msghead(std::string* msghead);

  // bytes msgBody = 2;
  void clear_msgbody();
  static const int kMsgBodyFieldNumber = 2;
  const std::string& msgbody() const;
  void set_msgbody(const std::string& value);
  void set_msgbody(std::string&& value);
  void set_msgbody(const char* value);
  void set_msgbody(const void* value, size_t size);
  std::string* mutable_msgbody();
  std::string* release_msgbody();
  void set_allocated_msgbody(std::string* msgbody);

  // @@protoc_insertion_point(class_scope:message.PNPCMessage)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msghead_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msgbody_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_IMessage_2eproto;
};
// -------------------------------------------------------------------

class HeadClient final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:message.HeadClient) */ {
 public:
  HeadClient();
  virtual ~HeadClient();

  HeadClient(const HeadClient& from);
  HeadClient(HeadClient&& from) noexcept
    : HeadClient() {
    *this = ::std::move(from);
  }

  inline HeadClient& operator=(const HeadClient& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeadClient& operator=(HeadClient&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const HeadClient& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HeadClient* internal_default_instance() {
    return reinterpret_cast<const HeadClient*>(
               &_HeadClient_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(HeadClient* other);
  friend void swap(HeadClient& a, HeadClient& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HeadClient* New() const final {
    return CreateMaybeMessage<HeadClient>(nullptr);
  }

  HeadClient* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HeadClient>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const HeadClient& from);
  void MergeFrom(const HeadClient& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HeadClient* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "message.HeadClient";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string access_token = 3;
  void clear_access_token();
  static const int kAccessTokenFieldNumber = 3;
  const std::string& access_token() const;
  void set_access_token(const std::string& value);
  void set_access_token(std::string&& value);
  void set_access_token(const char* value);
  void set_access_token(const char* value, size_t size);
  std::string* mutable_access_token();
  std::string* release_access_token();
  void set_allocated_access_token(std::string* access_token);

  // string datetime = 4;
  void clear_datetime();
  static const int kDatetimeFieldNumber = 4;
  const std::string& datetime() const;
  void set_datetime(const std::string& value);
  void set_datetime(std::string&& value);
  void set_datetime(const char* value);
  void set_datetime(const char* value, size_t size);
  std::string* mutable_datetime();
  std::string* release_datetime();
  void set_allocated_datetime(std::string* datetime);

  // sint64 checkSum = 2;
  void clear_checksum();
  static const int kCheckSumFieldNumber = 2;
  ::PROTOBUF_NAMESPACE_ID::int64 checksum() const;
  void set_checksum(::PROTOBUF_NAMESPACE_ID::int64 value);

  // int32 commandId = 1;
  void clear_commandid();
  static const int kCommandIdFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::int32 commandid() const;
  void set_commandid(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:message.HeadClient)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr access_token_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr datetime_;
  ::PROTOBUF_NAMESPACE_ID::int64 checksum_;
  ::PROTOBUF_NAMESPACE_ID::int32 commandid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_IMessage_2eproto;
};
// -------------------------------------------------------------------

class HeadServer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:message.HeadServer) */ {
 public:
  HeadServer();
  virtual ~HeadServer();

  HeadServer(const HeadServer& from);
  HeadServer(HeadServer&& from) noexcept
    : HeadServer() {
    *this = ::std::move(from);
  }

  inline HeadServer& operator=(const HeadServer& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeadServer& operator=(HeadServer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const HeadServer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HeadServer* internal_default_instance() {
    return reinterpret_cast<const HeadServer*>(
               &_HeadServer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(HeadServer* other);
  friend void swap(HeadServer& a, HeadServer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HeadServer* New() const final {
    return CreateMaybeMessage<HeadServer>(nullptr);
  }

  HeadServer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HeadServer>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const HeadServer& from);
  void MergeFrom(const HeadServer& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HeadServer* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "message.HeadServer";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string msg = 4;
  void clear_msg();
  static const int kMsgFieldNumber = 4;
  const std::string& msg() const;
  void set_msg(const std::string& value);
  void set_msg(std::string&& value);
  void set_msg(const char* value);
  void set_msg(const char* value, size_t size);
  std::string* mutable_msg();
  std::string* release_msg();
  void set_allocated_msg(std::string* msg);

  // string datetime = 5;
  void clear_datetime();
  static const int kDatetimeFieldNumber = 5;
  const std::string& datetime() const;
  void set_datetime(const std::string& value);
  void set_datetime(std::string&& value);
  void set_datetime(const char* value);
  void set_datetime(const char* value, size_t size);
  std::string* mutable_datetime();
  std::string* release_datetime();
  void set_allocated_datetime(std::string* datetime);

  // sint64 checkSum = 2;
  void clear_checksum();
  static const int kCheckSumFieldNumber = 2;
  ::PROTOBUF_NAMESPACE_ID::int64 checksum() const;
  void set_checksum(::PROTOBUF_NAMESPACE_ID::int64 value);

  // int32 commandId = 1;
  void clear_commandid();
  static const int kCommandIdFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::int32 commandid() const;
  void set_commandid(::PROTOBUF_NAMESPACE_ID::int32 value);

  // int32 code = 3;
  void clear_code();
  static const int kCodeFieldNumber = 3;
  ::PROTOBUF_NAMESPACE_ID::int32 code() const;
  void set_code(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:message.HeadServer)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr datetime_;
  ::PROTOBUF_NAMESPACE_ID::int64 checksum_;
  ::PROTOBUF_NAMESPACE_ID::int32 commandid_;
  ::PROTOBUF_NAMESPACE_ID::int32 code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_IMessage_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// PNPCMessage

// bytes msgHead = 1;
inline void PNPCMessage::clear_msghead() {
  msghead_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& PNPCMessage::msghead() const {
  // @@protoc_insertion_point(field_get:message.PNPCMessage.msgHead)
  return msghead_.GetNoArena();
}
inline void PNPCMessage::set_msghead(const std::string& value) {
  
  msghead_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:message.PNPCMessage.msgHead)
}
inline void PNPCMessage::set_msghead(std::string&& value) {
  
  msghead_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:message.PNPCMessage.msgHead)
}
inline void PNPCMessage::set_msghead(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  msghead_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:message.PNPCMessage.msgHead)
}
inline void PNPCMessage::set_msghead(const void* value, size_t size) {
  
  msghead_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:message.PNPCMessage.msgHead)
}
inline std::string* PNPCMessage::mutable_msghead() {
  
  // @@protoc_insertion_point(field_mutable:message.PNPCMessage.msgHead)
  return msghead_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PNPCMessage::release_msghead() {
  // @@protoc_insertion_point(field_release:message.PNPCMessage.msgHead)
  
  return msghead_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PNPCMessage::set_allocated_msghead(std::string* msghead) {
  if (msghead != nullptr) {
    
  } else {
    
  }
  msghead_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msghead);
  // @@protoc_insertion_point(field_set_allocated:message.PNPCMessage.msgHead)
}

// bytes msgBody = 2;
inline void PNPCMessage::clear_msgbody() {
  msgbody_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& PNPCMessage::msgbody() const {
  // @@protoc_insertion_point(field_get:message.PNPCMessage.msgBody)
  return msgbody_.GetNoArena();
}
inline void PNPCMessage::set_msgbody(const std::string& value) {
  
  msgbody_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:message.PNPCMessage.msgBody)
}
inline void PNPCMessage::set_msgbody(std::string&& value) {
  
  msgbody_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:message.PNPCMessage.msgBody)
}
inline void PNPCMessage::set_msgbody(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  msgbody_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:message.PNPCMessage.msgBody)
}
inline void PNPCMessage::set_msgbody(const void* value, size_t size) {
  
  msgbody_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:message.PNPCMessage.msgBody)
}
inline std::string* PNPCMessage::mutable_msgbody() {
  
  // @@protoc_insertion_point(field_mutable:message.PNPCMessage.msgBody)
  return msgbody_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PNPCMessage::release_msgbody() {
  // @@protoc_insertion_point(field_release:message.PNPCMessage.msgBody)
  
  return msgbody_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PNPCMessage::set_allocated_msgbody(std::string* msgbody) {
  if (msgbody != nullptr) {
    
  } else {
    
  }
  msgbody_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msgbody);
  // @@protoc_insertion_point(field_set_allocated:message.PNPCMessage.msgBody)
}

// -------------------------------------------------------------------

// HeadClient

// int32 commandId = 1;
inline void HeadClient::clear_commandid() {
  commandid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 HeadClient::commandid() const {
  // @@protoc_insertion_point(field_get:message.HeadClient.commandId)
  return commandid_;
}
inline void HeadClient::set_commandid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  commandid_ = value;
  // @@protoc_insertion_point(field_set:message.HeadClient.commandId)
}

// sint64 checkSum = 2;
inline void HeadClient::clear_checksum() {
  checksum_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 HeadClient::checksum() const {
  // @@protoc_insertion_point(field_get:message.HeadClient.checkSum)
  return checksum_;
}
inline void HeadClient::set_checksum(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  checksum_ = value;
  // @@protoc_insertion_point(field_set:message.HeadClient.checkSum)
}

// string access_token = 3;
inline void HeadClient::clear_access_token() {
  access_token_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& HeadClient::access_token() const {
  // @@protoc_insertion_point(field_get:message.HeadClient.access_token)
  return access_token_.GetNoArena();
}
inline void HeadClient::set_access_token(const std::string& value) {
  
  access_token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:message.HeadClient.access_token)
}
inline void HeadClient::set_access_token(std::string&& value) {
  
  access_token_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:message.HeadClient.access_token)
}
inline void HeadClient::set_access_token(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  access_token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:message.HeadClient.access_token)
}
inline void HeadClient::set_access_token(const char* value, size_t size) {
  
  access_token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:message.HeadClient.access_token)
}
inline std::string* HeadClient::mutable_access_token() {
  
  // @@protoc_insertion_point(field_mutable:message.HeadClient.access_token)
  return access_token_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* HeadClient::release_access_token() {
  // @@protoc_insertion_point(field_release:message.HeadClient.access_token)
  
  return access_token_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void HeadClient::set_allocated_access_token(std::string* access_token) {
  if (access_token != nullptr) {
    
  } else {
    
  }
  access_token_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), access_token);
  // @@protoc_insertion_point(field_set_allocated:message.HeadClient.access_token)
}

// string datetime = 4;
inline void HeadClient::clear_datetime() {
  datetime_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& HeadClient::datetime() const {
  // @@protoc_insertion_point(field_get:message.HeadClient.datetime)
  return datetime_.GetNoArena();
}
inline void HeadClient::set_datetime(const std::string& value) {
  
  datetime_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:message.HeadClient.datetime)
}
inline void HeadClient::set_datetime(std::string&& value) {
  
  datetime_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:message.HeadClient.datetime)
}
inline void HeadClient::set_datetime(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  datetime_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:message.HeadClient.datetime)
}
inline void HeadClient::set_datetime(const char* value, size_t size) {
  
  datetime_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:message.HeadClient.datetime)
}
inline std::string* HeadClient::mutable_datetime() {
  
  // @@protoc_insertion_point(field_mutable:message.HeadClient.datetime)
  return datetime_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* HeadClient::release_datetime() {
  // @@protoc_insertion_point(field_release:message.HeadClient.datetime)
  
  return datetime_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void HeadClient::set_allocated_datetime(std::string* datetime) {
  if (datetime != nullptr) {
    
  } else {
    
  }
  datetime_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), datetime);
  // @@protoc_insertion_point(field_set_allocated:message.HeadClient.datetime)
}

// -------------------------------------------------------------------

// HeadServer

// int32 commandId = 1;
inline void HeadServer::clear_commandid() {
  commandid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 HeadServer::commandid() const {
  // @@protoc_insertion_point(field_get:message.HeadServer.commandId)
  return commandid_;
}
inline void HeadServer::set_commandid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  commandid_ = value;
  // @@protoc_insertion_point(field_set:message.HeadServer.commandId)
}

// sint64 checkSum = 2;
inline void HeadServer::clear_checksum() {
  checksum_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 HeadServer::checksum() const {
  // @@protoc_insertion_point(field_get:message.HeadServer.checkSum)
  return checksum_;
}
inline void HeadServer::set_checksum(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  checksum_ = value;
  // @@protoc_insertion_point(field_set:message.HeadServer.checkSum)
}

// int32 code = 3;
inline void HeadServer::clear_code() {
  code_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 HeadServer::code() const {
  // @@protoc_insertion_point(field_get:message.HeadServer.code)
  return code_;
}
inline void HeadServer::set_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:message.HeadServer.code)
}

// string msg = 4;
inline void HeadServer::clear_msg() {
  msg_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& HeadServer::msg() const {
  // @@protoc_insertion_point(field_get:message.HeadServer.msg)
  return msg_.GetNoArena();
}
inline void HeadServer::set_msg(const std::string& value) {
  
  msg_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:message.HeadServer.msg)
}
inline void HeadServer::set_msg(std::string&& value) {
  
  msg_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:message.HeadServer.msg)
}
inline void HeadServer::set_msg(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  msg_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:message.HeadServer.msg)
}
inline void HeadServer::set_msg(const char* value, size_t size) {
  
  msg_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:message.HeadServer.msg)
}
inline std::string* HeadServer::mutable_msg() {
  
  // @@protoc_insertion_point(field_mutable:message.HeadServer.msg)
  return msg_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* HeadServer::release_msg() {
  // @@protoc_insertion_point(field_release:message.HeadServer.msg)
  
  return msg_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void HeadServer::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  msg_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msg);
  // @@protoc_insertion_point(field_set_allocated:message.HeadServer.msg)
}

// string datetime = 5;
inline void HeadServer::clear_datetime() {
  datetime_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& HeadServer::datetime() const {
  // @@protoc_insertion_point(field_get:message.HeadServer.datetime)
  return datetime_.GetNoArena();
}
inline void HeadServer::set_datetime(const std::string& value) {
  
  datetime_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:message.HeadServer.datetime)
}
inline void HeadServer::set_datetime(std::string&& value) {
  
  datetime_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:message.HeadServer.datetime)
}
inline void HeadServer::set_datetime(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  datetime_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:message.HeadServer.datetime)
}
inline void HeadServer::set_datetime(const char* value, size_t size) {
  
  datetime_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:message.HeadServer.datetime)
}
inline std::string* HeadServer::mutable_datetime() {
  
  // @@protoc_insertion_point(field_mutable:message.HeadServer.datetime)
  return datetime_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* HeadServer::release_datetime() {
  // @@protoc_insertion_point(field_release:message.HeadServer.datetime)
  
  return datetime_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void HeadServer::set_allocated_datetime(std::string* datetime) {
  if (datetime != nullptr) {
    
  } else {
    
  }
  datetime_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), datetime);
  // @@protoc_insertion_point(field_set_allocated:message.HeadServer.datetime)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace message

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_IMessage_2eproto
